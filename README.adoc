//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microprofile-reactive-messaging
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-04-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Reactive Messaging to implement an application with a reactive architecture.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['containerize']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Creating asynchronous Java microservices using MicroProfile Reactive Messaging 
:page-seo-description: A getting started tutorial with examples on how to send and receive messages between asynchronous Java microservices using MicroProfile Reactive Messaging and Apache Kafka.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Creating asynchronous reactive microservices using MicroProfile Reactive Messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to use MicroProfile Reactive Messaging to implement an application with a reactive architecture.

== What you'll learn

You will learn how to build reactive microservices using MicroProfile Reactive Messaging. You'll also learn how to send messages between these microservices using Apache Kafka. 

=== What is MicroProfile Reactive Messaging?

Temporal decoupling of services in a microservice-based architecture can be achieved using asynchronous communication. MicroProfile Reactive Messaging provides a way to build systems of microservices which advocates responsiveness, location transparency, elasticity, resiliency to failure and temporal decoupling. This helps in enforcing asynchronous message passing between the different parts of the system. See
https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_microprofile_reactive_messaging[ MicroProfile Reactive Messaging Specification^] for more information.

=== What is Kafka?

https://kafka.apache.org/[Apache Kafka^] is a stream-processing platform that manages communication in distributed systems. Communication is message-oriented, and follows the publish-subscribe model. Kafka allows for real-time stream processing and distributed, replicated storage of streams and messages. A Kafka producer is a client or a program, which produces the message and pushes them to a topic. A Kafka consumer is a client or a program, which consumes the published messages from a topic.

=== What is asynchronous programming?
Imagine asynchronous programming as a restaurant. After you're seated, a waitstaff takes your order. Then, you must wait a few minutes for your food to be prepared. While your food is being prepared, your waitstaff may take more orders or serve other tables. After your food is ready, your waitstaff brings out the food to your table. However, in a synchronous model, the waitstaff must wait for your food to be prepared before serving any other customers. This method blocks other customers from placing orders or receiving their food.

The OpenLiberty Cafe application that you'll be working with consists of three important microservices : `Kitchen`, `Order`, and `Status`. It also uses Kafka to enable reactive messaging communication between the Producer and Consumer microservices over the messaging channels.

You'll update the `Kitchen`, `Order` and `Status` microservices to use MicroProfile Reactive Messaging for message passing. These microservices run on Open Liberty.

image::reactive-messaging-restaurant.png[Reactive restaurant,align="center"]

The `OpenLibertyCafe` microservice is a https://microservices.io/patterns/apigateway.html#variation-backends-for-frontends[backend for frontend^] service.
It communicates with the backend microservices on the caller's behalf.

The waitstaff places a request using the `OpenLibertyCafe` microservice.

The `Order` microservice consumes the request, produces order messages, and sends them to Kafka on the `food` channel.

An order begins with a `NEW` status. The `Kitchen` microservices illustrate how to handle the orders as a real cafe. It consume and process the order and update the status to `IN_PROGRESS` and `READY` consecutively. There’s a sleep operation in between each status to represent the order processing time, and the status updates are reported back to the `Status` microservice via reactive messages on the Kafka.

The `Status` microservice receives status updates and provides queries for the waitstaff. All the orders are persisted here. Because persisting data is not the focus of this guide, the `Status` microservice simply uses a Map object to store the data.

// =================================================================================================
// Prerequisites
// =================================================================================================
== Additional prerequisites

You will build and run the  microservices in Docker containers. You can learn more about containerizing microservices with Docker in the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Install Docker by following the instructions on the official https://docs.docker.com/engine/installation[Docker documentation^]. Start your Docker environment.

// =================================================================================================
// Getting started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

== Creating a Reactive Messaging application

=== Key Concepts

MicroProfile Reactive Messaging recommends a design to build reactive applications based on the following main concepts:

*Channel*

A channel is a bridge for transporting messages between different parts of the reactive system. This can be between the service and a messaging-broker, or between two components within the same service.

*@Outgoing* 

`@Outgoing` is an annotation indicating that the method feeds a channel. The name of the channel is given as attribute. For example, `@Outgoing("food")`

*@Incoming*

`@Incoming` is an annotation indicating that the method consumes a channel. The name of the channel is given as attribute. For example, `@Incoming("foodOrderConsume")`

*Connector*

MicroProfile Reactive Messaging uses connectors to attach one end of a channel to another messaging technology and are configured using MicroProfile Config.
Open Liberty includes the `liberty-kafka` connector for sending and receiving messages from Apache Kafka.

Detailed diagram with the MicroProfile Reactive Messaging channels, Apache Kafka topics and the interaction between them :

image::reactive-messaging-restaurant-detail.png[Reactive restaurant detail,align="center"]

---

=== Configuring MicroProfile Reactive Messaging connectors

Navigate to the `start` directory to begin. Most of the code is already provided for use.

In order to configure the MicroProfile Reactive Messaging connectors, we need to format the configuration keys as follows :

- `mp.messaging.connector.liberty-kafka.` :- Applies to all channels using the liberty-kafka connector
- `mp.messaging.[incoming.|outgoing.].` :- Applies to a particular channel
- Each channel which is to be connected using a connector must have the connector property defined to say which connector to use

Each of the three microservices `Kitchen`, `Order`, and `Status` contain `microprofile-config.properties`
file. MicroProfile Reactive Messaging uses connectors to connect certain channels to Apache Kafka and setting options on those connectors.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the microprofile-config.properties file.#
`kitchen/src/main/resources/META-INF/microprofile-config.properties`
----
kitchen/microprofile-config.properties
[source, text, linenums, role='code_column']
----
include::finish/kitchen/src/main/resources/META-INF/microprofile-config.properties[]
----

The [hotspot=kafkaConfig file=0]`mp.messaging.connector.liberty-kafka.bootstrap.servers` property defines the Kafka connector for the Open Liberty runtime. The `Kitchen` microservice uses an outgoing stream [hotspot=foodOrderPublishStatus file=0]`foodOrderPublishStatus` to send messages to the [hotspot=topic1 file=0]`statusTopic` topic in the Kafka messaging-broker, so that the `Status` microservices can consume the messages.

The `Kitchen` microservice listens to messages from an incoming stream [hotspot=foodOrderConsume file=0]`foodOrderConsume`, wherein the messages are sent by the `Order` microservice through the [hotspot=topic2 file=0]`foodTopic` topic in the Kafka messaging-broker. The [hotspot=serializer1 file=0]`key.serializer` and [hotspot=serializerVal1 hotspot=serializerVal2 file=0]`value.serializer` properties characterize how to serialize the messages. Similarly the [hotspot=deserializer2 file=0]`key.deserializer` and [hotspot=deserializerVal2 file=0]`value.deserializer` properties define how to deserialize the messages.

The [hotspot=group file=0]`group.id` defines a unique name for the consumer group. All these properties are required by the https://kafka.apache.org/documentation/#producerconfigs[Apache Kafka Producer Configs^] and https://kafka.apache.org/documentation/#consumerconfigs[Apache Kafka Consumer Configs^].

The rest of the microservices use similar `microprofile-config.properties` configuration to define their required incoming and outgoing streams.

image::reactive-messaging-keyconcepts.png[Reactive key concepts,align="center"]

---

=== Building the Order microservice

The `Order` microservice uses the MicroProfile Reactive Messaging to send messages to the `Kitchen` microservice over Kafka.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `OrderResource` class.#
`order/src/main/java/io/openliberty/guides/order/OrderResource.java`
----

OrderResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/order/src/main/java/io/openliberty/guides/order/OrderResource.java[]
----

order/microprofile-config.properties
[source, Text, linenums, role='code_column hide_tags=copyright']
----
include::finish/order/src/main/resources/META-INF/microprofile-config.properties[]
----

The `Order` microservice creates orders when an order is sent in a [hotspot=postOrder file=0]`POST` request to the `/orders` endpoint. The [hotspot=createOrder file=0]`createOrder()` method receive a [hotspot=foodOrder file=0]`food` order and adds it to the [hotspot=fOrderQueue hotspot=bOrderQueue file=0]`FlowableEmitter`. We use [hotspot=takeF hotspot=takeB file=0]`Flowable.create()` from rxJava to create a Publisher and an associated emitter. Objects we send to the emitter will be sent to the `Publisher`. We return the `Publisher` from our [hotspot=OutgoingFood file=0]`@Outgoing("food")` channel, which is configured in the [hotspot file=1]`microprofile-config.properties` [hotspot=foodStream file=1]`food` stream and MicroProfile Reactive Messaging takes care of assigning the publisher to the channel.

[role="code_command hotspot file=2", subs="quotes"]
----
#Replace the Maven configuration file.#
`order/pom.xml`
---- 

pom.xml
[source, XML ,linenums,role="code_column"]
----
include::finish/order/pom.xml[]
----

In order to develop the MicroProfile Reactive Messaging application using Maven, add the [hotspot=reactiveMessaging file=2]`microprofile-reactive-messaging-api`, [hotspot=kafka file=2]`kafka-clients`, and [hotspot=rxjava file=2]`rxjava` dependencies to the [hotspot file=2]`pom.xml`

---

=== Completing the Kitchen and Status microservices

You will complete the `Kitchen` and `Status` microservices implementation in this section.

*Completing the Kitchen microservice*

//Kitchen
[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `KitchenService` class.#
`kitchen/src/main/java/io/openliberty/guides/kitchen/KitchenService.java`
----
KitchenService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/kitchen/src/main/java/io/openliberty/guides/kitchen/KitchenService.java[]
----

If the order is an item of food, `Kitchen` service receives an order on the [hotspot=foodOrderConsume file=0]`@Incoming("foodOrderConsume")` channel, processes it in [hotspot=initFoodOrder file=0]`receiveFoodOrder()` method and sends back an `IN_PROGRESS` status on the [hotspot=foodOrderPublishIntermediate file=0]`@Outgoing("foodOrderPublishStatus")` channel to Kafka over MicroProfile Reactive Messaging channels. After a while, a `READY` status will be sent to the [hotspot=foodOrder file=0]`@Outgoing("foodOrderPublishStatus")` channel.

*Completing the Status microservice*

//status
[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `StatusResource` class.#
`status/src/main/java/io/openliberty/guides/status/StatusResource.java`
----

StatusResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/status/src/main/java/io/openliberty/guides/status/StatusResource.java[]
----

status/microprofile-config.properties
[source, Text, linenums, role='code_column hide_tags=copyright']
----
include::finish/status/src/main/resources/META-INF/microprofile-config.properties[]
----

The `Status` microservice receives the message from the `Kitchen`, and `Order` microservices over the [hotspot=updateStatus file=1]`@Incoming("updateStatus")` channel with its properties defined in the [hotspot=updateStatus file=2]`microprofile-config.properties`.
 
== Configuring the server

To use MicroProfile Reactive Messaging, we must enable the feature in the server.xml file for each service.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the kitchen server.xml configuration file.#
`kitchen/src/main/liberty/config/server.xml`
----
server.xml
[source,xml,linenums,role="code_column"]
----
include::finish/kitchen/src/main/liberty/config/server.xml[]
----

Configure the server to enable MicroProfile Reactive Messaging by adding [hotspot=featureMP file=0]`mpReactiveMessaging-1.0` feature element to the [hotspot file=0]`server.xml`.

The rest of the microservices have [hotspot file=0]`server.xml` already configured.

== Building the application

You will build and run the `Kitchen`, `Order`, `OpenLibertyCafe`, and `Status` microservices in Docker containers.

Start your Docker environment.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

Run the following command to download or update the `open-liberty` docker image to latest.
[role='command']
```
docker pull open-liberty
```

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t kitchen:1.0-SNAPSHOT kitchen/.
docker build -t openlibertycafe:1.0-SNAPSHOT openLibertyCafe/.
docker build -t order:1.0-SNAPSHOT order/.
docker build -t status:1.0-SNAPSHOT status/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and all of the microservices in the project.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Trying the application

Once the application is up and running, you can access the application by making requests to the `OpenLibertyCafe` endpoint using OpenAPI.

The services may take some time to become available. Check out the service that you created at the
http://localhost:9080/openapi/ui[^] URL.

*Place Orders*

Make a `POST` request to the `/api/orders` endpoint. To make this request, expand the `POST` endpoint on the UI and click the *Try it out button*. Copy the following example input into the text box, and then click the `Execute` button. The `POST` request adds a new `food` Order.

[source, role='command']
----
{
  "tableId": "1",
  "foodList": [
    "burger"
  ]
}
----

*Check IN_PROGRESS Order Status*

Next, make a `GET` request to the `/api/status` endpoint. To make this request, expand the `GET` endpoint on the UI, click the *Try it out button*, and then click the `Execute` button. The `GET` request returns information about the Orders. The response should show that the Orders have an `IN_PROGRESS` status, In case you see a `NEW` status then wait for a couple of seconds and click the `Execute` button again.

[source, role="no_copy"]
----
[
  {
    "item": "burger",
    "orderId": "0001",
    "status": "IN_PROGRESS",
    "tableId": "1",
    "type": "FOOD"
  }
]
----

*Check READY Order Status*

Click `Execute` again and you will see the response with a `READY` status. In case you see an `IN_PROGRESS` status then wait for a couple of seconds and click the `Execute` button again.

[source, role="no_copy"]
----
[
  {
    "item": "burger",
    "orderId": "0001",
    "status": "READY",
    "tableId": "1",
    "type": "FOOD"
  }
]
----

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just developed an application using MicroProfile Reactive Messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html[View the MicroProfile Reactive Messaging Specification^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/apidocs/[View the MicroProfile Reactive Messaging Javadoc^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

include::{common-includes}/attribution.adoc[subs="attributes"]
