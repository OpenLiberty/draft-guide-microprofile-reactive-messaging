//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microprofile-reactive-messaging
:page-layout: guide-multipane
:page-duration: 15 minutes
:page-releasedate: 2020-04-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Reactive Messaging to implement an application with a reactive architecture.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['containerize']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Creating asynchronous Java microservices using MicroProfile Reactive Messaging 
:page-seo-description: A getting started tutorial with examples on how to send and receive messages between asynchronous Java microservices using MicroProfile Reactive Messaging and Apache Kafka.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Creating reactive microservices using MicroProfile Reactive Messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to use MicroProfile Reactive Messaging to implement an application with a reactive architecture.

== What you'll learn

You will learn how to build reactive microservices using MicroProfile Reactive Messaging. You'll also learn how to send messages between these microservices using Apache Kafka. 

=== What is asynchronous programming?

Imagine asynchronous programming as a restaurant. After you're seated, a waitstaff takes your order. Then, you must wait a few minutes for your food to be prepared. While your food is being prepared, your waitstaff may take more orders or serve other tables. After your food is ready, your waitstaff brings out the food to your table. However, in a synchronous model, the waitstaff must wait for your food to be prepared before serving any other customers. This method blocks other customers from placing orders or receiving their food.

You can perform lengthy operations, such as input/output (I/O), without blocking with asynchronous methods. The I/O operation can occur in the background and a callback notifies the caller to continue its computation when the original request is complete. As a result, the original thread frees up so it can handle other work rather than wait for the I/O to complete. Revisiting the restaurant analogy, food is prepared asynchronously in the kitchen and your waitstaff is freed up to attend to other tables.

In the context of REST clients, HTTP request calls can be time consuming. The network might be slow, or maybe the upstream service is overwhelmed and can’t respond quickly. These lengthy operations can block the execution of your thread when it’s in use and prevent other work from being completed.

=== What is Reactive programming?

Reactive programming is a programming paradigm that is designed around asynchronous data streams and it's propagation of change. It encourages non-blocking and event-driven outlook for data processing. Reactive Microservices are single function modules that are loosely coupled and message-driven.

=== What is MicroProfile Reactive Messaging?

Temporal decoupling of services in a microservice-based architecture can be achieved using asynchronous communication. In a microservice-based architecture, temporal coupling can result in a fragile system, with resilience and scaling properties that are worse than a monolith. One way to avoid this is to embrace asynchronous communication as much as possible.

MicroProfile Reactive Messaging provides a very easy-to-use way to send, receive, and process messages asynchronously and is well-suited to writing applications that process streams of events. With MicroProfile Reactive Messaging, you annotate application beans' methods and, under the covers, Liberty converts these to reactive streams-compatible publishers, subscribers and processors and connects them up to each other. It also provides a Connector API to allow your methods to be connected to external messaging systems.

See the
https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_microprofile_reactive_messaging[ MicroProfile Reactive Messaging Specification^] for more information.

=== What is Kafka?

https://kafka.apache.org/[Apache Kafka^] is a stream-processing platform that manages communication in distributed systems. Communication is message-oriented, and follows the publish-subscribe model. Kafka allows for real-time stream processing and distributed, replicated storage of streams and messages. A Kafka producer is a client or a program, which produces the message and pushes them to a topic. A Kafka consumer is a client or a program, which consumes the published messages from a topic.

The application that you will be working with consists of two microservices, `system` and `inventory`. The `system` microservice sends the system load average data to the `inventory` microservice every 15 seconds. The `inventory` microservice keeps an updated list of all the `system` hostnames and their CPU data.

You'll update the `system` and `inventory` microservices to use MicroProfile Reactive Messaging for message passing. These microservices run on Open Liberty.

image::reactive-messaging-system-inventory.png[Reactive system inventory,align="center"]

The `inventory` microservice receives status updates and provides queries for the user. The `system` metadata are persisted here. Because persisting data is not the focus of this guide, the `inventory` microservice simply uses a Map object to store the data.

// =================================================================================================
// Prerequisites
// =================================================================================================
== Additional prerequisites

You will build and run the  microservices in Docker containers. You can learn more about containerizing microservices with Docker in the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Install Docker by following the instructions on the official https://docs.docker.com/engine/installation[Docker documentation^]. Start your Docker environment.

The application also requires Apache Kafka however you will be using Kafka Docker containers to reduce the installation and configuration.

// =================================================================================================
// Getting started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

== MicroProfile Reactive Messaging Key Concepts

MicroProfile Reactive Messaging recommends a design to build reactive applications based on the following main concepts:

*Channel*

A channel is a bridge for transporting messages between different parts of the reactive system. This can be between the service and a messaging-broker, or between two components within the same service.

*@Outgoing* 

`@Outgoing` is an annotation indicating that the method feeds a channel. The name of the channel is given as attribute. For example, `@Outgoing("systemLoad")`.

*@Incoming*

`@Incoming` is an annotation indicating that the method consumes a channel. The name of the channel is given as attribute. For example, `@Incoming("systemLoad")`.

*Connector*

MicroProfile Reactive Messaging uses connectors to attach one end of a channel to another messaging technology and are configured using MicroProfile Config.
Open Liberty includes the `liberty-kafka` connector for sending and receiving messages from Apache Kafka.

Here's a detailed diagram with the MicroProfile Reactive Messaging channels, Apache Kafka topics and the interaction between them :

image::reactive-messaging-system-inventory-detail.png[Reactive system inventory detail,align="center"]

== Building the Producer in the system microservice

Navigate to the `start` directory to begin. 

The `system` microservice uses the MicroProfile Reactive Messaging to send CPU usage messages to the `inventory` microservice over Kafka.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

system/microprofile-config.properties
[source, Text, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/resources/META-INF/microprofile-config.properties[]
----

The `system` microservice calculates the average system load for the last minute every fifteen seconds. The average system load for a system is calculated by taking the sum of the count of runnable items queued to the available processors and the count of runnable items running on the available processors averaged over a period of time.

The [hotspot=sendSystemLoad file=0]`sendSystemLoad()` method creates CPU system load statistics for a host system every fifteen seconds. The [hotspot=flowableInterval file=0]`Flowable.interval()` from rxJava is used to create a `Publisher`. The `Publisher` is returned from the [hotspot=publishSystemLoad file=0]`@Outgoing("systemLoad")` channel, which will be configured in the [hotspot file=1]`microprofile-config.properties` [hotspot=systemLoad file=1]`systemLoad` stream in the below section. MicroProfile Reactive Messaging takes care of assigning the `Publisher` to the channel.

[role="code_command hotspot file=2", subs="quotes"]
----
#Replace the Maven configuration file.#
`system/pom.xml`
---- 

pom.xml
[source, XML ,linenums,role="code_column"]
----
include::finish/system/pom.xml[]
----

In order to develop the MicroProfile Reactive Messaging application using Maven, add the [hotspot=reactiveMessaging file=2]`microprofile-reactive-messaging-api`, [hotspot=kafka file=2]`kafka-clients`, and [hotspot=rxjava file=2]`rxjava` dependencies to the [hotspot file=2]`pom.xml`

== Building the Consumer in the inventory microservice

The `inventory` microservice stores the information about the CPU usage that runs on different systems.

//inventory
[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `InventoryResource` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java`
----

InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

inventory/microprofile-config.properties
[source, Text, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/resources/META-INF/microprofile-config.properties[]
----

The `inventory` microservice receives the message from the `system` microservice over the [hotspot=systemLoad file=0]`@Incoming("systemLoad")` channel with its properties defined in the [hotspot=systemLoad file=1]`microprofile-config.properties`. It's also a RESTful service that is served at the [hotspot=inventoryEndPoint file=0]`/inventory` endpoint.

== Configuring the MicroProfile Reactive Messaging connectors

In order to configure the MicroProfile Reactive Messaging connectors, you need to format the configuration keys as follows :

- `mp.messaging.connector.liberty-kafka.` : Applies to all channels using the liberty-kafka connector
- `mp.messaging.[incoming|outgoing].<channel name>.<property name>` : Applies to a particular channel
- Each channel which is to be connected using a connector must have the `connector` property defined to say which connector to use

Both the `system` and `inventory` microservices use connectors to connect certain channels to Apache Kafka and these connectors are configured by setting properties using MicroProfile Config. This is done by setting the required properties inside the `microprofile-config.properties` file included in each microservice.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the system microprofile-config.properties file.#
`system/src/main/resources/META-INF/microprofile-config.properties`
----
system/microprofile-config.properties
[source, text, linenums, role='code_column']
----
include::finish/system/src/main/resources/META-INF/microprofile-config.properties[]
----

inventory/microprofile-config.properties
[source, text, linenums, role='code_column']
----
include::finish/inventory/src/main/resources/META-INF/microprofile-config.properties[]
----

models/SystemLoad.java
[source, text, linenums, role='code_column']
----
include::finish/models/src/main/java/io/openliberty/guides/models/SystemLoad.java[]
----

The [hotspot=kafkaConfig file=0]`mp.messaging.connector.liberty-kafka.bootstrap.servers` property configures the hostname and port of the Kafka server for all channels which use the Kafka connector. The `system` microservice uses an outgoing connector to send messages from the [hotspot=systemLoad file=0]`systemLoad` channel to the [hotspot=topic1 file=0]`systemLoadTopic` topic in the Kafka messaging-broker, so that the `inventory` microservices can consume the messages. The [hotspot=serializer1 file=0]`key.serializer` and [hotspot=serializerVal1 file=0]`value.serializer` properties characterize how to serialize the messages. The class [hotspot=jsonbSerializer file=2]`SystemLoadSerializer()` implements the logic for turning a `SystemLoad` object into json and is configured as the [hotspot=serializerVal1 file=0]`value.serializer`.

The `inventory` microservices uses a similar `microprofile-config.properties` configuration to define its required incoming stream.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the inventory microprofile-config.properties file.#
`inventory/src/main/resources/META-INF/microprofile-config.properties`
----

The `inventory` microservice uses an incoming connector to receive messages on the [hotspot=systemLoad file=1]`systemLoad` channel which were sent by the `system` microservice to the [hotspot=topic1 file=1]`systemLoadTopic` in the Kafka messaging-broker. Similarly the [hotspot=deserializer1 file=1]`key.deserializer` and [hotspot=deserializerVal1 file=1]`value.deserializer` properties define how to deserialize the messages. The class [hotspot=jsonbDeSerializer file=2]`SystemLoadDeserializer()` implements the logic for turning a `SystemLoad` object into json and is configured as the [hotspot=deserializerVal1 file=1]`value.deserializer`.

The [hotspot=group1 file=1]`group.id` defines a unique name for the consumer group. All these properties are required by the https://kafka.apache.org/documentation/#producerconfigs[Apache Kafka Producer Configs^] and https://kafka.apache.org/documentation/#consumerconfigs[Apache Kafka Consumer Configs^].
 
== Configuring the server

To use MicroProfile Reactive Messaging, you must enable the feature in the server.xml file for each service.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the system server.xml configuration file.#
`system/src/main/liberty/config/server.xml`
----
server.xml
[source,xml,linenums,role="code_column"]
----
include::finish/system/src/main/liberty/config/server.xml[]
----

server.xml
[source,xml,linenums,role="code_column"]
----
include::finish/inventory/src/main/liberty/config/server.xml[]
----

Configure the server to enable MicroProfile Reactive Messaging by adding [hotspot=featureMP file=0]`mpReactiveMessaging-1.0` feature element to the [hotspot file=0]`server.xml`.

The `inventory` microservice has [hotspot file=1]`server.xml` already configured.

== Building the application

You will build and run the `system` and `inventory` microservices in Docker containers.

Start your Docker environment.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

Run the following command to download or update to the latest open-liberty Docker image.
[role='command']
```
docker pull open-liberty
```

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and all of the microservices in the project.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Testing the application

Once the application is up and running, you can access the application by making a `@GET` request to the `inventory` endpoint. 

To access the `inventory` microservice, use the http://localhost:9085/inventory/systems[^] URL, and you see the CPU systemLoad property for all the systems.

[source, role='no_copy']
----
{
   "hostname":"Ankits-MacBook-Pro.local",
   "systemLoad":2.25927734375
}
----

You can rerun the http://localhost:9085/inventory/systems[^] URL after a while, and you will notice the CPU systemLoad property for all the systems have changed.

You can use the `@GET` `\http://localhost:9085/inventory/system/{hostId}` URL to see the CPU systemLoad property for one particular system.

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just developed an application using MicroProfile Reactive Messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html[View the MicroProfile Reactive Messaging Specification^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/apidocs/[View the MicroProfile Reactive Messaging Javadoc^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

include::{common-includes}/attribution.adoc[subs="attributes"]
