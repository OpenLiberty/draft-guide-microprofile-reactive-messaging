//  Copyright (c) 2017, 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: foodOrderRestaurantApp
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-01-15
:page-guide-category: microprofile
:page-essential: true
:page-essential-order: 1
:page-description: Learn how to create a microservice with MP-reactive messaging and Open Liberty.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Java EE', 'Jakarta EE']
:page-related-guides: []
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Creating a MP-reactive messaging REST service 
:page-seo-description: A tutorial on how to create a microservices in Open Liberty using MP-reactive messaging
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Creating asynchronous reactive microservices using MP-reactive messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to create a REST microservices with MP-reactive messaging, and Open Liberty.

== What you'll learn

You will learn how to build microservices using MicroProfile reactive messaging. You'll also learn how to send messages between these microservices using Kafka broker. 

=== What is MP-reactive messaging?

Asynchronous communication allows temporal decoupling of services in a microservice-based architecture. MicroProfile Reactive Messaging delivers a way to build systems of microservices promoting responsive, non-blocking, location transparency, elastic, resiliency to failure and temporal decoupling, enforcing asynchronous message passing between the different parts of the system.

=== What is Kafka?

https://kafka.apache.org/[Apache Kafka^] is a stream-processing platform that manages communication in distributed systems. Communication is message-oriented, and follows the publish-subscribe model. Kafka allows for real-time stream processing and distributed, replicated storage of streams and messages.

=== What is asynchronous programming?
Imagine asynchronous programming as a restaurant. After you're seated, a waiter takes your order. Then, you must wait a few minutes for your food to be prepared. While your food is being prepared, your waiter may take more orders or serve other tables. After your food is ready, your waiter brings out the food to your table. However, in a synchronous model, the waiter must wait for your food to be prepared before serving any other customers. This method blocks other customers from placing orders or receiving their food.

The Reactive Restaurant application mentioned below is designed on Microservices architecture. The application has five microservices and uses Kafka broker to enable reactive messaging communication between the Producer and Consumer microservices over the messaging channels.

You'll update the `order`, `kitchen, `bar`, and `servingWindow` microservices to use MP-microprofile reactive messaging for message passing. These microservices run on Open Liberty servers.

image::reactive-messaging-restaurant.png[Reactive restaurant,align="center"]

The Restaurant application that you'll be working with consists of five microservices namely `restaurantBFF`, `order`, `servingWindow`, `kitchen` and `bar`.

The `restaurantBFF` service is a https://microservices.io/patterns/apigateway.html#variation-backends-for-frontends[backend for frontend^] service.
It communicates with the backend microservices on the caller's behalf.

The waiter places a request using the `restaurantBFF` service.

The `order` microservice consumes the request, produces order messages, and sends them to Kafka on the `food` or `beverage` channel depending on the type.

An order begins with a NEW status. The `kitchen` and `bar` microservices consume and processes the order and updates the status to IN_PROGRESS and READY consecutively. There’s a sleep operation in between each status to represent the cooking time, and the status updates are reported back to the `order` microservice via reactive messages on Kafka.

The `servingWindow` microservice contains a list of all ready to serve food and beverages. It consumes these statuses from kitchen and bar microservices.
Once the order is served, it’s marked as COMPLETED and the status is sent back to the `order` microservice as a message.



// =================================================================================================
// Prerequisites
// =================================================================================================
== Additional prerequisites

You will build and run the  microservices in Docker containers. You can learn more about containerizing microservices with Docker in the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Install Docker by following the instructions on the official https://docs.docker.com/engine/installation[Docker documentation^]. Start your Docker environment.

//add kafka data

// Getting Started

[role='command']
include::{common-includes}/gitclone.adoc[]

USE this Github Link for the time being:

`https://github.com/ankitagrawa/foodOrderRestaurantApp`

=== Try what you'll build
The `finish` directory in the root of this guide contains the finished application. Give it a try before you proceed.

To try out the application, first go to the `finish` directory and run the following Maven 
goal to build the application and deploy it to Open Liberty:
[role='command']
```
mvn liberty:run
```

== Creating a reactive messaging application

This section will describe the following topics and explain the required code:

=== @Outgoing
Outgoing is an annotation indicating that the method feeds a channel. The name of the channel is given as attribute:

=== @Incoming
Incoming is an annotation indicating that the method consumes a channel. The name of the channel is given as attribute

=== channel
A channel is a name indicating which source or destination of messages is used. Channels are opaque Strings

=== Connector
Reactive messaging uses Connectors to attach one end of a channel  and are configured using MicroProfile Config.
Open Liberty includes the liberty-kafka connector for sending and receiving messages from an Apache Kafka broker.

Navigate to the `start` directory to begin.

 Start Open Liberty in development mode, which starts the Open Liberty server and listens 
 for file changes:

 [role="command"]
 ```
 mvn liberty:dev
 ```



// [role="code_command hotspot" ,subs="quotes"]
// ----
// #Replace the `SystemApplication` class.#
// `src/main/java/io/openliberty/guides/rest/SystemApplication.java`
// ----

// The [hotspot=systemApplication]`SystemApplication` class extends the `Application` class, which in turn associates all JAX-RS
// resource classes in the WAR file with this JAX-RS application, making them available under the common
// path specified in the [hotspot=systemApplication]`SystemApplication` class. The [hotspot=applicationPath]`@ApplicationPath` annotation has a
// value that indicates the path within the WAR that the JAX-RS application accepts requests from.

// SystemApplication.java
// [source, Java, linenums, role='code_column hide_tags=comment']
// ----
// include::finish/src/main/java/io/openliberty/guides/rest/SystemApplication.java[]
// ----

//            //== Creating the JAX-RS resource

// In JAX-RS, a single class should represent a single resource, or a group of resources of the same type.
// In this application, a resource might be a system property, or a set of system properties. It is easy
// to have a single class handle multiple different resources, but keeping a clean separation between types
// of resources helps with maintainability in the long run.

// [role="code_command hotspot", subs="quotes"]
// ----
// #Create the `PropertiesResource` class.#
// `src/main/java/io/openliberty/guides/rest/PropertiesResource.java`
// ----

// This resource class has quite a bit of code in it, so let's break it down into manageable chunks.

// The [hotspot=path file=0]`@Path` annotation on the class indicates that this resource responds to the `properties` path
// in the JAX-RS application. The [hotspot=applicationPath file=1]`@ApplicationPath` annotation in the [hotspot=systemApplication file=1]`SystemApplication` class together with
// the [hotspot=path file=0]`@Path` annotation in this class indicates that the resource is available at the `System/properties`
// path.

// JAX-RS maps the HTTP methods on the URL to the methods on the class. The method to call is determined
// by the annotations that are specified on the methods. In the application you are building, an HTTP `GET` request
// to the `System/properties` path results in the system properties being returned.

// The [hotspot=get file=0]`@GET` annotation on the method indicates that this method is to be called for the HTTP `GET`
// method. The [hotspot=produces file=0]`@Produces` annotation indicates the format of the content that will be returned. The
// value of the [hotspot=produces file=0]`@Produces` annotation will be specified in the HTTP `Content-Type` response header.
// For this application, a JSON structure is to be returned. The desired `Content-Type` for a JSON
// response is `application/json` with `MediaType.APPLICATION_JSON` instead of the `String` content type. Using a constant such as `MediaType.APPLICATION_JSON` is better because if there's a spelling error, a compile failure occurs.

// JAX-RS supports a number of ways to marshal JSON. The JAX-RS 2.1 specification mandates JSON-Binding
// (JSON-B) and JAX-B. 

// The method body returns the result of `System.getProperties()` that is of type `java.util.Properties`. Since the method 
// is annotated with `@Produces(MediaType.APPLICATION_JSON)`, JAX-RS uses JSON-B to automatically convert the returned object
// to JSON data in the HTTP response.

// PropertiesResource.java
// [source,java,linenums,role='code_column hide_tags=comment']
// ----
// include::finish/src/main/java/io/openliberty/guides/rest/PropertiesResource.java[]
// ----

// SystemApplication.java
// [source,java,linenums,role='code_column hide_tags=comment']
// ----
// include::finish/src/main/java/io/openliberty/guides/rest/SystemApplication.java[]
// ----

== Configuring the server

This section will enlist the server.xml configuration


To get the service running, the Liberty server needs to be correctly configured.

 [role="code_command hotspot", subs="quotes"]
 ----
 #Replace the server configuration file.#
 `src/main/liberty/config/server.xml`
 ----

 server.xml
 [source,xml,linenums,role="code_column"]
 ----
 include::finish/src/main/liberty/config/server.xml[]
 ----

 The configuration does the following actions:

 . Configures the server to enable MP-reactive messaging. This is specified in the [hotspot=featureManager file=0]`featureManager` element.
 `<feature>mpReactiveMessaging-1.0</feature>`
// . Configures the server to resolve the HTTP port numbers from variables, which are then specified in
// the Maven [hotspot=defaultHttpPort hotspot=defaultHttpsPort file=1]`pom.xml` file. This is specified in the [hotspot=httpEndpoint file=0]`<httpEndpoint/>` element. Variables use the `${variableName}` syntax.
// . Configures the server to run the produced web application on a context root specified in the 
// [hotspot=appContextRoot file=1]`pom.xml` file. This is specified in the [hotspot=webApplication file=0]`<webApplication/>` element.

// pom.xml
// [source,xml,linenums,role="code_column"]
// ----
// include::finish/pom.xml[]
// ----

// The variables that are being used in the [hotspot=httpEndpoint hotspot=webApplication file=0]`server.xml` file are provided by the properties set in the Maven [hotspot=defaultHttpPort hotspot=defaultHttpsPort hotspot=appContextRoot file=1]`pom.xml` file. The properties must be formatted as `liberty.var.variableName`.

== Building and running the application

// How to build and run the application

// add name of the micro services
Instructions on how to build and run the application. This will enlist various steps required.

// The Open Liberty server was started in development mode at the beginning of the guide and all the 
// changes were automatically picked up.

// Check out the service that you created at the
// http://localhost:9080/LibertyProject/System/properties[^] URL. 


== Testing the service

Test development

You will create an unit tests to test the basic functionality of the microservices. If a test failure occurs, then you may have introduced a bug into the code.

// You can test this service manually by starting a server and pointing a web browser at the
// http://localhost:9080/LibertyProject/System/properties[^] URL. Automated tests are a much better
// approach because they trigger a failure if a change introduces a bug. JUnit and the JAX-RS Client
// API provide a simple environment to test the application.

// You can write tests for the individual units of code outside of a running application server, or they
// can be written to call the application server directly. In this example, you will create a test that
// does the latter.

// [role="code_command hotspot", subs="quotes"]
// ----
// #Create the `EndpointIT` class.#
// `src/test/java/it/io/openliberty/guides/rest/EndpointIT.java`
// ----

// EndpointIT.java
// [source, Java, linenums, role="code_column hide_tags=comment"]
// ----
// include::finish/src/test/java/it/io/openliberty/guides/rest/EndpointIT.java[]
// ----

// This test class has more lines of code than the resource implementation. This situation is common.
// The test method is indicated with the [hotspot=test file=0]`@Test` annotation.

// pom.xml
// [source , xml, linenums,role="code_column"]
// ----
// include::finish/pom.xml[]
// ----

// The test code needs to know some information about the application to make requests. The server port and the application context root are key, and are dictated by the server configuration. While this information can be hardcoded, it is better to specify it in a single place like the Maven [hotspot=defaultHttpPort hotspot=defaultHttpsPort hotspot=appContextRoot file=1]`pom.xml` file. Refer to the [hotspot file=1]`pom.xml` file to see how the application information such as the [hotspot=defaultHttpPort file=1]`default.http.port`, [hotspot=defaultHttpsPort file=1]`default.https.port` and [hotspot=appContextRoot file=1]`app.context.root` elements are provided in the file.


// These Maven properties are then passed to the Java test program as the [hotspot=testsysprops file=1]`<systemPropertyVariables/>` element in the [hotspot file=1]`pom.xml` file.

// Getting the values to create a representation of the URL is simple. The test class uses the [hotspot=systemProperties file=0]`getProperty` method
// to get the application details.

// To call the JAX-RS service using the JAX-RS client, first create a `WebTarget` object by calling
// the [hotspot=target file=0]`target` method that provides the URL. To cause the HTTP request to occur, the [hotspot=requestget file=0]`request().get()` method
// is called on the `WebTarget` object. The [hotspot=requestget file=0]`get` method
// call is a synchronous call that blocks until a response is received. This call returns a [hotspot=requestget file=0]`Response`
// object, which can be inspected to determine whether the request was successful.

// The first thing to check is that a `200` response was received. The JUnit [hotspot=assertequals file=0]`assertEquals` method can be used for this check.

// Check the response body to ensure it returned the right information. Since the client and the server
// are running on the same machine, it is reasonable to expect that the system properties for the local
// and remote JVM would be the same. In this case, an [hotspot=assertosname file=0]`assertEquals` assertion is made so that the `os.name` system property
// for both JVMs is the same. You can write additional assertions to check for more values.

=== Running the tests

Run tests

Navigate to the directory, then verify that the tests pass by using the Maven `verify` goal:

[role='command']
```
mvn verify
```

When the tests succeed, you see output similar to the following example:
// Since you started Open Liberty in development mode at the start of the guide, press
// `enter/return` key to run the tests. You will see the following output:

// [source,role="no_copy"]
// ----
// -------------------------------------------------------
//  T E S T S
// -------------------------------------------------------
// Running it.io.openliberty.guides.rest.EndpointIT
// Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.884 sec - in it.io.openliberty.guides.rest.EndpointIT

// Results :

// Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
// ----

// To see whether the tests detect a failure, add an assertion that you know fails, or change the existing
// assertion to a constant value that doesn't match the `os.name` system property.

// When you are done checking out the service, exit development mode by typing `q` in the shell session where
// you ran the server and then pressing the `enter/return` key.


== Great work! You're done!

You have just developed an application using MP-reactive messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://microprofile.io/[See the MicroProfile specs^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]


include::{common-includes}/attribution.adoc[subs="attributes"]
