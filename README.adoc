//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microprofile-reactive-messaging
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-01-15
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Reactive Messaging to implement an application with a reactive architecture.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['containerize']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Creating a MicroProfile Reactive Messaging REST service
:page-seo-description: A tutorial on how to create a microservices in Open Liberty using MicroProfile Reactive Messaging
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Creating asynchronous reactive microservices using MicroProfile Reactive Messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to use MicroProfile Reactive Messaging to implement reactive architecture application.

== What you'll learn

You will learn how to build reactive microservices using MicroProfile Reactive Messaging. You'll also learn how to send messages between these microservices using Apache Kafka broker. 

=== What is MicroProfile Reactive Messaging?

Temporal decoupling of services in a microservice-based architecture could be achieved using asynchronous communication. MicroProfile Reactive Messaging provides a way to build systems of microservices advocating responsiveness, location transparency, elasticity, resiliency to failure and temporal decoupling. This helps in enforcing asynchronous message passing between the different parts of the system. See
https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_microprofile_reactive_messaging[ MicroProfile Reactive Messaging Specification^] for more information.

=== What is Kafka?

https://kafka.apache.org/[Apache Kafka^] is a stream-processing platform that manages communication in distributed systems. Communication is message-oriented, and follows the publish-subscribe model. Kafka allows for real-time stream processing and distributed, replicated storage of streams and messages. Kafka Producer is a client or a program, which produces the message and pushes it to the Topic. Whereas Kafka Consumer is a client or a program, which consumes the published messages from the Producer.

=== What is asynchronous programming?
Imagine asynchronous programming as a restaurant. After you're seated, a waiter takes your Order. Then, you must wait a few minutes for your food to be prepared. While your food is being prepared, your waiter may take more orders or serve other tables. After your food is ready, your waiter brings out the food to your table. However, in a synchronous model, the waiter must wait for your food to be prepared before serving any other customers. This method blocks other customers from placing orders or receiving their food.

The Restaurant application is designed with reactive architecture. The application that you'll be working with consists of five microservices : `order`, `kitchen`, `bar`, `servingWindow`, and `restaurantBFF`. It also uses Kafka broker to enable reactive messaging communication between the Producer and Consumer microservices over the messaging channels.

You'll update the `order`, `kitchen`, `bar`, and `servingWindow` microservices to use MicroProfile Reactive Messaging for message passing. These microservices run on Open Liberty.

image::reactive-messaging-restaurant.png[Reactive restaurant,align="center"]

The `restaurantBFF` microservice is a https://microservices.io/patterns/apigateway.html#variation-backends-for-frontends[backend for frontend^] service.
It communicates with the backend microservices on the caller's behalf.

The waiter places a request using the `restaurantBFF` microservice.

The `order` microservice consumes the request, produces Order messages, and sends them to Kafka on the `food` or `beverage` channel depending on the type.

An Order begins with a `NEW` status. The `kitchen` and `bar` microservices consume and process the Order and update the status to `IN_PROGRESS` and `READY` consecutively. There’s a sleep operation in between each status to represent the Order processing time, and the status updates are reported back to the `order` microservice via reactive messages on Kafka.

The `servingWindow` microservice contains a list of all ready-to-serve food and beverages. It consumes these statuses from the `kitchen` and `bar` microservices.
Once the Order is served, it’s marked as `COMPLETED` and the status is sent back to the `order` microservice as a message.

// =================================================================================================
// Prerequisites
// =================================================================================================
== Additional prerequisites

You will build and run the  microservices in Docker containers. You can learn more about containerizing microservices with Docker in the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Install Docker by following the instructions on the official https://docs.docker.com/engine/installation[Docker documentation^]. Start your Docker environment.

// =================================================================================================
// Getting started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

== Creating a Reactive Messaging application

=== Key Concepts

MicroProfile Reactive Messaging recommends a design to build reactive applications based on the following main concepts:

*Channel*

A channel is a name indicating which source or destination of messages is used. Channels are opaque Strings.

*@Outgoing* 

Outgoing is an annotation indicating that the method feeds a channel. The name of the channel is given as attribute.

*@Incoming*

Incoming is an annotation indicating that the method consumes a channel. The name of the channel is given as attribute.

*Connector*

Reactive messaging uses Connectors to attach one end of a channel to other messaging technology and are configured using MicroProfile Config.
Open Liberty includes the `liberty-kafka` connector for sending and receiving messages from an Apache Kafka broker.

=== Configuring the MicroProfile Reactive Messaging

//File 0
microprofile-config.properties
[source, Text, linenums, role='code_column hide_tags=copyright']
----
include::finish/order/src/main/resources/META-INF/microprofile-config.properties[]
----

Navigate to the `start` directory to begin. Most of the code is already provided for use.

Each of the four microservices `order`, `kitchen`, `bar`, and `servingWindow` contain `microprofile-config.properties`
file, which configures Kafka connector with the MicroProfile Reactive Messaging channels.

[role="code_command hotspot", subs="quotes"]
----
#Create the microprofile-config.properties file.#
`order/src/main/resources/META-INF/microprofile-config.properties`
----

The [hotspot=kafkaConfig file=0]`mp.messaging.connector.liberty-kafka.bootstrap.servers` property defines the Kafka connector for the Open Liberty runtime. The `order` microservice uses two Outgoing streams [hotspot=foodStream file=0]`food` and [hotspot=bevStream file=0]`beverage`, and one Incoming stream [hotspot=updateStatus file=0]`updateStatus`. All these streams connect to the connector [hotspot=kafka1 hotspot=kafka2 hotspot=kafka3 file=0]`liberty-kafka`. The [hotspot=topic1 hotspot=topic2 hotspot=topic3 file=0]`topic` property defines the topics in Kafka broker, which are used to communicate with the `kitchen` and `bar`  microservices. The [hotspot=serializer1 hotspot=serializer2 file=0]`key.serializer` and [hotspot=serializerVal1 hotspot=serializerVal2 file=0]`value.serializer` properties characterize how to serialize the messages. Similarly [hotspot=deserializer1 file=0]`key.deserializer` and [hotspot=deserializerVal1 file=0]`value.deserializer` properties define how to deserialize the messages. The [hotspot=group file=0]`group.id` defines an unique name for the consumer group. All those properties should be understood by the https://kafka.apache.org/documentation/#api[Apache Kafka client API^].

The rest of the microservices use similar `microprofile-config.properties` configuration.

=== Building the order microservice

The `order` microservice uses MicroProfile Reactive Messaging to send messages to `kitchen` and `bar` microservices over Kafka.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `OrderResource` class.#
`order/src/main/java/io/openliberty/guides/order/OrderResource.java`
----
OrderResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/order/src/main/java/io/openliberty/guides/order/OrderResource.java[]
----

microprofile-config.properties
[source, Text, linenums, role='code_column hide_tags=copyright']
----
include::finish/order/src/main/resources/META-INF/microprofile-config.properties[]
----

The `order` microservice creates Orders when the [hotspot=postOrder file=0]`POST` request of the endpoint `/orders` is called. The [hotspot=createOrder file=0]`createOrder()` method receives [hotspot=foodOrder file=0]`food` or [hotspot=beverageOrder file=0]`beverage` Orders and adds it to the respective [hotspot=fOrderQueue hotspot=bOrderQueue file=0]`LinkedBlockingQueue`. As soon as an Order is added to the Queue, the [hotspot=takeF hotspot=takeB file=0]`take()` method retrieves and removes the Orders. The Reactive Messaging implementation generates Reactive Streams for those Orders and publishes it to Kafka over [hotspot=OutgoingFood file=0]`@Outgoing("food")` or [hotspot=OutgoingBev file=0]`@Outgoing("beverage")` channels, which we configured previously in the `microprofile-config.properties` [hotspot=foodStream file=1]`food` or [hotspot=bevStream file=1]`beverage` stream. The [hotspot=IncomingStatus file=0]`@Incoming("updateStatus")` channel with its properties defined in the [hotspot=updateStatus file=1]`microprofile-config.properties` receives updated Order statuses from the Kafka topic which is being sent by `kitchen` or `bar` microservices.

[role="code_command hotspot file=2", subs="quotes"]
----
 #Replace the Maven configuration file.#
 `order/pom.xml`
---- 
pom.xml
[source, XML ,linenums,role="code_column"]
----
include::finish/order/pom.xml[]
----

- In order to develop the MicroProfile Reactive Messaging application using Maven, add the [hotspot=reactiveMessaging file=2]`microprofile-reactive-messaging-api` and [hotspot=kafka file=2]`kafka-clients` dependencies to the `pom.xml`

=== Building the other microservices

The `kitchen`, `bar` and `servingWindow` microservices are put together in this section.

*Building the kitchen microservice*

//Kitchen
[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `KitchenResource` class.#
`kitchen/src/main/java/io/openliberty/guides/kitchen/KitchenResource.java`
----
KitchenResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/kitchen/src/main/java/io/openliberty/guides/kitchen/KitchenResource.java[]
----

If the order is a food, `kitchen` service receives an Order on the [hotspot=foodOrderConsume file=0]`@Incoming("foodOrderConsume")` channel, processes it in [hotspot=initFoodOrder file=0]`initFoodOrder()` method and sends back an `IN_PROGRESS` status on the [hotspot=foodOrderPublishIntermediate file=0]`@Outgoing("foodOrderPublishIntermediate")` channel and a `READY` status on the [hotspot=foodOrder file=0]`@Outgoing("foodOrderPublish")` channel to Kafka over MicroProfile Reactive Messaging channels.

*Building the bar microservice*

//bar
[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `BarResource` class.#
`bar/src/main/java/io/openliberty/guides/bar/BarResource.java`
----
BarResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/bar/src/main/java/io/openliberty/guides/bar/BarResource.java[]
----

If the order is a drink, `bar` service receives an Order on the [hotspot=bevOrderConsume file=1]`@Incoming("bevOrderConsume")` channel, processes it in [hotspot=initBevOrder file=1]`initBeverageOrder()` method and sends back an `IN_PROGRESS` status on the [hotspot=bevOrderPublishInter file=1]`@Outgoing("bevOrderPublishInter")` channel and a `READY` status on the [hotspot=bevOrder file=1]`@Outgoing("beverageOrderPublish")` channel to Kafka over MicroProfile Reactive Messaging channels.

*Building the servingWindow microservice*

//servingWindow
[role="code_command hotspot file=2", subs="quotes"]
----
#Replace the `ServingWindowResource` class.#
`servingWindow/src/main/java/io/openliberty/guides/servingWindow/ServingWindowResource.java`
----
ServingWindowResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/servingWindow/src/main/java/io/openliberty/guides/servingWindow/ServingWindowResource.java[]
----

The `servingWindow` microservice receives a `Ready` Order from the `bar` and `kitchen` microservices over the [hotspot=addReadyOrder file=2]`@Incoming("orderReady")` channel.
Once the Order is served, it's marked as `COMPLETED` and the status is sent across to the `order` microservice using the [hotspot=sendCompletedOrder file=2]`@Outgoing("completedOrder")` channel.

== Configuring the server

To get the service running, the Open Liberty server needs to be correctly configured.

[role="code_command hotspot file=0", subs="quotes"]
----
 #Replace the bar server.xml configuration file.#
 `bar/src/main/liberty/config/server.xml`
----
server.xml
[source,xml,linenums,role="code_column"]
----
include::finish/bar/src/main/liberty/config/server.xml[]
----

Configure the server to enable MicroProfile Reactive Messaging by adding [hotspot=featureMP file=0]`mpReactiveMessaging-1.0` feature element to the `server.xml`.

The rest of the microservices have `server.xml` already configured.

== Building the application

You will build and run the `order`, `kitchen`, `bar`, `servingWindow` and `restaurantBFF` microservices in Docker containers.

Start your Docker environment.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

Run the following command to download or update the `open-liberty` docker image to latest.
[role='command']
```
docker pull open-liberty
```

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t order:1.0-SNAPSHOT order/.
docker build -t kitchen:1.0-SNAPSHOT kitchen/.
docker build -t bar:1.0-SNAPSHOT bar/.
docker build -t servingwindow:1.0-SNAPSHOT servingWindow/.
docker build -t restaurantbff:1.0-SNAPSHOT restaurantBFF/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and all of the microservices in the project.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Trying the application

Once the application is up and running, you can access the application by making requests to the `restaurantBFF` endpoint using OpenAPI.

The services take some time to become available. Check out the service that you created at the
http://localhost:9080/openapi/ui[^] URL.

*Place Orders*

Make a `POST` request to the `/api/orders` endpoint. To make this request, expand the `POST` endpoint on the UI, click the *Try it out button*. Copy the following example input into the text box, and then click the `Execute` button. The `POST` request adds a new `food` and `beverage` Order.

[source, role='command']
----
{
  "tableId": "1",
  "foodList": [
    "burger"
  ],
  "beverageList": [
    "coke"
  ]
}
----

*Check IN_PROGRESS Order Status*

Next, make a `GET` request to the `/api/orders` endpoint. To make this request, expand the `GET` endpoint on the UI, click the *Try it out button*, and then click the `Execute` button. The `GET` request returns information about the Orders. The response shows that the Orders have an `IN_PROGRESS` status.

[source, role="no_copy"]
----
[
  {
    "item": "burger",
    "orderId": "0001",
    "status": "IN_PROGRESS",
    "tableId": "1",
    "type": "FOOD"
  },
  {
    "item": "coke",
    "orderId": "0002",
    "status": "IN_PROGRESS",
    "tableId": "1",
    "type": "BEVERAGE"
  }
]
----

*Check READY Order Status*

Click `Execute` again and you will see the response with a `READY` status. 

[source, role="no_copy"]
----
[
  {
    "item": "burger",
    "orderId": "0001",
    "status": "READY",
    "tableId": "1",
    "type": "FOOD"
  },
  {
    "item": "coke",
    "orderId": "0002",
    "status": "READY",
    "tableId": "1",
    "type": "BEVERAGE"
  }
]
----

*Complete an Order*

Make a `POST` request to the `/api/servingWindow/{orderId}` endpoint to complete an Order. Expand the `POST` endpoint on the UI, click the *Try it out* button. Copy the following orderId into the text box, and then click the `Execute` button. The status for the `orderId 0002` is changed from `READY` to `COMPLETED` and the updated status is cascaded to the `order` microservice.
 
[source, role='command']
----

0002
----

Then, make a `GET` request to the `/api/orders` endpoint again and verify that the status for the order with an `orderId` of `0002` is now labelled as `COMPLETED`.

[source, role="no_copy"]
----
[
  {
    "item": "burger",
    "orderId": "0001",
    "status": "IN_PROGRESS",
    "tableId": "1",
    "type": "FOOD"
  },
  {
    "item": "coke",
    "orderId": "0002",
    "status": "COMPLETED",
    "tableId": "1",
    "type": "BEVERAGE"
  }
]
----

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just developed an application using MicroProfile Reactive Messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://microprofile.io/[See the MicroProfile specs^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_microprofile_reactive_messaging[View the MicroProfile Reactive Messaging Specification^]

include::{common-includes}/attribution.adoc[subs="attributes"]
